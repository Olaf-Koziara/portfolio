{
  "nav": {
    "hero": "Start",
    "skills": "Umiejętności",
    "projects": "Projekty",
    "businessProjects": "Projekty Biznesowe",
    "experience": "Doświadczenie",
    "about": "O mnie",
    "contact": "Kontakt"
  },
  "hero": {
    "greeting": "Cześć, jestem",
    "name": "Olaf Koziara",
    "role": "Frontend Developer",
    "description": "Buduję skalowalne aplikacje webowe w React i Angular. 3+ lata doświadczenia komercyjnego, focus na performance i dostępność.",
    "cta": {
      "projects": "Zobacz Projekty",
      "cv": "Pobierz CV"
    }
  },
  "skills": {
    "title": "Technologie",
    "subtitle": "Narzędzia, z którymi pracuję"
  },
  "projects": {
    "title": "Wybrane Projekty",
    "subtitle": "Moje najnowsze prace",
    "viewLive": "Demo",
    "viewCode": "GitHub",
    "viewCaseStudy": "Case study",
    "items": [
      {
        "name": "Orbitask manager",
        "description": "Menedżer zadań z synchronizacją real-time, drag & drop i funkcjami zespołowymi.",
        "stack": [
          "React",
          "TypeScript",
          "Tailwind",
          "Zustand",
          "Node.js",
          "MongoDB"
        ],
        "liveUrl": "https://orbitask.olafwebdev.site/",
        "githubUrl": "https://github.com/Olaf-Koziara/orbitask-manager",
        "caseStudies": [
          {
            "title": ""
          }
        ]
      }
    ]
  },
  "businessProjects": {
    "title": "Projekty Biznesowe",
    "subtitle": "Realizacje dla organizacji i korporacji",
    "client": "Klient",
    "year": "Okres",
    "scopeOfWork": "Zakres prac",
    "viewCaseStudy": "Zobacz case study",
    "items": [
      {
        "id": "gkpge-formbuilder",
        "name": "FormBuilder dla wewnętrznego CMS",
        "client": "PGE Systemy",
        "year": "2021-2023",
        "description": "Narzędzie do budowania formularzy zintegrowane z platformą CMS. Panel oparty na Angular z TypeScriptem, zintegrowany z backendem Symfony/Twig.",
        "scope": ["Angular", "TypeScript", "RxJS", "TWIG", "SCSS"]
      },
      {
        "id": "gkpge-cms",
        "name": "Motyw i komponenty CMS dla Grupy PGE",
        "client": "Grupa Kapitalowa PGE",
        "year": "2021-2023",
        "description": "Stworzenie motywu oraz biblioteki reużywalnych komponentów dla CMS Grupy PGE. Projekt obejmował unifikację identyfikacji wizualnej i usprawnienie procesu zarządzania contentem.",
        "scope": ["Web Design", "Web Development", "TWIG", "SCSS", "JavaScript"]
      },

      {
        "id": "gkpge-newsletter-pwa",
        "name": "PGE Newsletter (PWA / Offline-first)",
        "client": "Grupa Kapitalowa PGE",
        "year": "2022-2023",
        "description": "Progressive Web App do dystrybucji newslettera wewnętrznego z architekturą offline-first, Service Workers i implementacją w React zorientowaną na wydajność, osiągając stały wynik Lighthouse 95+ dla performance i accessibility.",
        "scope": [
          "React",
          "TypeScript",
          "PWA",
          "Service Workers",
          "Lighthouse",
          "Accessibility"
        ]
      }
    ]
  },
  "experience": {
    "title": "Doświadczenie",
    "subtitle": "Moja zawodowa podróż",
    "items": [
      {
        "company": "SunGroup",
        "role": "Frontend Developer",
        "period": "Kwi 2025 - Lip 2025",
        "points": [
          "Rozwijałem bibliotekę reużywalnych komponentów webowych (PHP, JS, CSS) w pełnej zgodności z WCAG 2.2",
          "Biblioteka została wdrożona na ponad 100 stronach landing page, zapewniając spójność wizualną i dostępność",
          "Współpracowałem z zespołem UI/UX przy implementacji pixel-perfect interfejsów"
        ]
      },
      {
        "company": "PGE Systemy",
        "role": "Frontend Developer",
        "period": "Lip 2021 - Wrz 2024",
        "points": [
          "Tworzyłem aplikacje webowe w React i Angular dla największej grupy energetycznej w Polsce",
          "PWA Newsletter — zaimplementowałem offline-first z Service Workers, osiągając wynik Lighthouse 95+",
          "Aplikacja raportowania finansowego — zbudowałem rozwiązanie Next.js z GraphQL API obsługujące ponad 1000 zapytań dziennie",
          "Form Builder CMS — zaprojektowałem system dynamicznych formularzy z zależnościami między polami, używany w całej grupie kapitałowej",
          "Core Theme — stworzyłem bibliotekę reużywalnych komponentów (TWIG/SASS/JS) dla wszystkich witryn Grupy PGE"
        ]
      },
      {
        "company": "Freelance",
        "role": "Fullstack Developer",
        "period": "Mar 2022 - Obecnie",
        "points": [
          "Customizacja rozwiązań Comarch B2B — Angular na frontendzie, C#/.NET/SQL na backendzie",
          "Budowa aplikacji WordPress i Next.js z integracją bramek płatności",
          "Optymalizacja SEO legacy websites — wzrost ruchu organicznego o ponad 30%",
          "Automatyzacja przepływu pracy — plugin osTicket do migracji ticketów do Redmine"
        ]
      }
    ]
  },
  "about": {
    "title": "O Mnie",
    "subtitle": "Trochę więcej o tym, kim jestem",
    "paragraphs": [
      "Frontend developer z 3+ letnim doświadczeniem komercyjnym, specjalizujący się w React i Angular. Dodatkowo uczę się i wykorzystuję Node.js w projektach, co pozwala mi efektywnie współpracować z backendem i rozumieć pełny cykl życia aplikacji.",
      "Pracowałem nad aplikacjami dla dużych organizacji — od zaawansowanych form builderów obsługujących setki użytkowników po responsywne PWA z wynikiem Lighthouse 95+. Dostarczam rozwiązania, które działają, są czytelne w kodzie i przyjemne w użyciu.",
      "Lubię zagłębiać się w architekturę aplikacji, eksperymentować z nowymi technologiami i dzielić się wiedzą z innymi. Jeśli szukasz kogoś, kto podejdzie do projektu z prawdziwym zaangażowaniem i nie boi się wyzwań technicznych — porozmawiajmy."
    ]
  },
  "contact": {
    "title": "Skontaktuj się",
    "subtitle": "Pracujmy razem",
    "email": "Wyślij Email",
    "form": {
      "name": "Imię",
      "email": "Email",
      "message": "Wiadomość",
      "send": "Wyślij Wiadomość"
    }
  },
  "footer": {
    "rights": "Wszelkie prawa zastrzeżone."
  },
  "caseStudy": {
    "backToProjects": "Powrót do Projektów",
    "overview": "Przegląd",
    "techStack": "Stack Technologiczny",
    "keyFeatures": "Kluczowe Funkcje",
    "technicalHighlights": "Aspekty Techniczne",
    "demoAccount": "Konto Demo",
    "processTitle": "Proces Realizacji",
    "processSubtitle": "Od pierwszych rozmów do wdrożenia na produkcję",
    "visualComparison": "Porównanie Wizualne",
    "orbitaskmanager": {
      "title": "OrbiTask Manager",
      "tagline": "Zarządzanie Zadaniami i Projektami",
      "description": "Aplikacja do zarządzania zadaniami i projektami, zaprojektowana w celu zwiększenia produktywności poprzez inteligentną organizację, wizualne przepływy pracy i współpracę.",
      "demoUrl": "https://orbitask-manager-1.onrender.com/",
      "demoCredentials": {
        "email": "test@gmail.com",
        "password": "12test34"
      },
      "overview": {
        "intro": "OrbiTask Manager to aplikacja full-stack demonstrująca nowoczesne praktyki tworzenia aplikacji webowych. Zbudowana jako osobiste narzędzie do zwiększania produktywności.",
        "goals": [
          "Usprawnienie zarządzania zadaniami i planowania projektów",
          "Implementacja skalowalnej architektury dla rosnącej złożoności",
          "Stworzenie intuicyjnego interfejsu z wieloma trybami widoku",
          "Budowa modularnego designu ułatwiającego dodawanie funkcji"
        ]
      },
      "features": [
        {
          "title": "Wiele Trybów Widoku",
          "description": "Tablica Kanban, widok Kalendarza i Lista dla różnych przepływów pracy"
        },
        {
          "title": "System Priorytetów",
          "description": "Klasyfikacja priorytetów: Niski, Średni, Wysoki i Pilny"
        },
        {
          "title": "Przeciągnij i Upuść",
          "description": "Intuicyjne zarządzanie zadaniami z płynnym przeciąganiem"
        },
        {
          "title": "Współpraca Zespołowa",
          "description": "Przypisywanie zadań, udostępnianie projektów i wspólna praca"
        },
        {
          "title": "Zaawansowane Filtrowanie",
          "description": "Filtruj według projektu, osoby przypisanej, priorytetu i więcej"
        }
      ],
      "techStack": {
        "frontend": [
          "React 18",
          "TypeScript",
          "Vite",
          "Tailwind CSS",
          "Shadcn/ui",
          "React Query",
          "Zustand"
        ],
        "backend": [
          "Node.js",
          "Express.js",
          "tRPC",
          "MongoDB",
          "Mongoose",
          "JWT",
          "Zod"
        ]
      },
      "highlights": [
        {
          "id": "type-safety",
          "title": "End-to-End Type Safety",
          "problem": "W tradycyjnych REST API, gdy zmienisz pole na backendzie, frontend dowiaduje się o tym dopiero gdy wystąpią błędy w czasie wykonania.",
          "solution": "Użycie tRPC do automatycznej synchronizacji typów między frontendem a backendem bez generowania kodu.",
          "impact": "Zero błędów typów w runtime, natychmiastowy refactoring w całym stacku, autocomplete wszędzie.",
          "code": {
            "backend": "export const taskRouter = router({\n  create: protectedProcedure\n    .input(z.object({\n      title: z.string().min(1).max(100),\n      priority: z.enum(['low', 'medium', 'high', 'urgent']),\n      dueDate: z.date().optional(),\n    }))\n    .mutation(async ({ input, ctx }) => {\n      return await TaskModel.create({\n        ...input,\n        createdBy: ctx.user.id,\n      });\n    }),\n});",
            "frontend": "export const useTasks = () => {\n  const createTask = trpc.tasks.create.useMutation();\n  \n  // TypeScript ZNA WSZYSTKO o tym API\n  createTask.mutate({\n    title: \"Nowe zadanie\",\n    priority: \"high\",\n    dueDate: new Date('2026-02-01'),\n  });\n};"
          }
        },

        {
          "id": "optimistic-updates",
          "title": "Optymistyczne Aktualizacje z Cofnięciem",
          "problem": "Użytkownik klika 'Oznacz jako Wykonane' → czeka 500ms na API → w końcu widzi zmianę. Czuje się wolno.",
          "solution": "Natychmiastowa aktualizacja UI (optymistycznie), synchronizacja z backendem w tle, automatyczne cofnięcie przy błędach.",
          "impact": "Aplikacja działa błyskawicznie. Nie czekamy na API. Automatyczne cofnięcie przy błędach.",
          "code": {
            "implementation": "export const useTasks = () => {\n  const updateTaskStatus = useCallback(\n    async (taskId: string, newStatus: TaskStatus) => {\n      const originalTasks = [...tasks];\n      \n      const optimisticTasks = tasks.map(task =>\n        task._id === taskId ? { ...task, status: newStatus } : task\n      );\n      setTasks(optimisticTasks);\n      \n      try {\n        await utils.client.tasks.update.mutate({\n          id: taskId,\n          data: { status: newStatus },\n        });\n        \n        await utils.tasks.invalidate();\n      } catch (error) {\n        setTasks(originalTasks);\n        toast.error(\"Nie udało się zaktualizować zadania.\");\n      }\n    },\n    [tasks, utils]\n  );\n};"
          }
        },

        {
          "id": "drag-drop-preview",
          "title": "Drag & Drop Preview w Sortowanych Listach",
          "problem": "Podczas przeciągania zadań użytkownik nie widzi gdzie dokładnie element zostanie upuszczony. W posortowanych listach (np. po priorytecie) trudno przewidzieć finalne położenie elementu.",
          "solution": "Implementacja preview overlay pokazującego dokładną pozycję docelową z uwzględnieniem aktualnego sortowania. Dynamiczne wyliczanie pozycji na podstawie algorytmu sortowania listy.",
          "impact": "Użytkownik zawsze widzi gdzie element wyląduje przed upuszczeniem. Eliminuje frustrację z nieprzewidywalnym zachowaniem drag & drop w sortowanych listach."
        }
      ]
    },
    "gkpge-cms": {
      "title": "Motyw CMS dla Grupy PGE",
      "tagline": "System komponentów dla korporacyjnego CMS",
      "description": "Zaprojektowanie i wdrożenie motywu oraz biblioteki komponentów reużywalnych dla systemu zarządzania treścią Grupy Kapitalowej PGE. Projekt objął odświeżenie identyfikacji wizualnej przy zachowaniu spójności na wszystkich stronach grupy.",
      "overview": {
        "intro": "Grupa Kapitalowa PGE to największa polska firma energetyczna, posiadająca kilkadziesiąt stron internetowych zarządzanych przez wewnętrzny CMS. Moim zadaniem było stworzenie nowego, wspólnego motywu wizualnego oraz zestawu komponentów, które mogą być używane przez wszystkie strony w grupie.",
        "goals": [
          "Odświeżenie identyfikacji wizualnej zgodnie z nowym brandingiem",
          "Stworzenie biblioteki komponentów wielokrotnego użytku",
          "Usprawnienie procesu tworzenia nowych stron",
          "Zapewnienie spójności wizualnej na wszystkich witrynach grupy"
        ]
      },
      "features": [
        {
          "title": "System Komponentów",
          "description": "Ponad 40 komponentów wielokrotnego użytku od przycisków po złożone layouty"
        },
        {
          "title": "Responsywność",
          "description": "Pełna responsywność na wszystkich urządzeniach od mobile po desktop"
        },
        {
          "title": "Dostępność",
          "description": "Zgodność z WCAG 2.1 dla zapewnienia dostępności dla wszystkich użytkowników"
        },
        {
          "title": "Wydajność",
          "description": "Zoptymalizowany kod CSS i JS dla szybkiego ładowania stron"
        }
      ],
      "techStack": {
        "frontend": [
          "TWIG",
          "SCSS",
          "JavaScript ES6+",
          "BEM",
          "CSS Grid",
          "Flexbox"
        ],
        "backend": ["Symfony", "PHP", "MySQL", "Doctrine ORM"]
      },
      "comparison": {
        "title": "Transformacja Wizualna",
        "beforeLabel": "Przed",
        "afterLabel": "Po"
      }
    },
    "gkpge-formbuilder": {
      "title": "FormBuilder dla CMS PGE",
      "tagline": "Narzędzie do budowania dynamicznych formularzy",
      "description": "Narzędzie do tworzenia formularzy z interfejsem drag & drop, obsługą zależności między polami oraz możliwością definiowania niestandardowych akcji po wysłaniu. FormBuilder został zintegrowany z wewnętrznym CMS grupy kapitalowej.",
      "overview": {
        "intro": "FormBuilder to narzędzie pozwalające redaktorom treści na tworzenie złożonych formularzy bez udziału programistów. Panel administracyjny oparty na Angular umożliwia wizualne projektowanie formularzy, które następnie są eksportowane jako JSON i renderowane przez backend Symfony. Po stronie przeglądarki stworzyłem dedykowany silnik w TypeScript, który na podstawie grafu zależności odtwarza wszystkie dynamiczne zachowania zdefiniowane w builderze.",
        "goals": [
          "Umożliwienie redaktorom samodzielnego tworzenia formularzy",
          "System zależności między polami z silnikiem grafu TypeScript",
          "Drag & drop interface z walidacją real-time"
        ]
      },
      "features": [
        {
          "title": "Drag & Drop",
          "description": "Intuicyjne przeciąganie komponentów formularza na canvas"
        },
        {
          "title": "Silnik Grafu Zależności",
          "description": "Dedykowany silnik TypeScript odtwarzający zależności na podstawie grafu połączeń między polami"
        },
        {
          "title": "Walidacja",
          "description": "Walidacja w czasie rzeczywistym po stronie klienta"
        }
      ],
      "techStack": {
        "frontend": [
          "Angular 12+",
          "TypeScript",
          "RxJS",
          "Angular CDK",
          "SCSS"
        ],
        "backend": ["Symfony", "TWIG", "PHP", "MySQL"]
      },
      "process": {
        "title": "Proces Realizacji Projektu",
        "subtitle": "Od pierwszych rozmów z biznesem do wdrożenia na produkcję",
        "steps": [
          {
            "id": "discovery",
            "title": "Rozmowy z Biznesem",
            "period": "Tydzień 1-2",
            "icon": "discovery",
            "description": "Projekt zaczął się od serii spotkań z zespołem biznesowym i redaktorami treści. Chciałem zrozumieć ich codzienne problemy i frustracje związane z obecnym procesem tworzenia formularzy. Okazało się, że każdy nowy formularz wymaga zgłoszeń do IT i czekania nawet kilka tygodni na realizację.",
            "details": [
              "Przeprowadziłem wywiady z 8 redaktorami treści z różnych spółek grupy",
              "Zidentyfikowałem główny problem - zbyt długi czas od pomysłu do publikacji formularza",
              "Zebrałem wymagania dotyczące typów pól i zależności między nimi",
              "Ustaliłem priorytety funkcjonalności z product ownerem"
            ]
          },
          {
            "id": "planning",
            "title": "Planowanie Architektury",
            "period": "Tydzień 3-4",
            "icon": "planning",
            "description": "Po zebraniu wymagań przyszedł czas na zaprojektowanie architektury systemu. Musiałem podjąć kilka kluczowych decyzji technicznych - jak przechowywać strukturę formularza, jak obsługiwać zależności między polami i jak zintegrować narzędzie z istniejącym CMS opartym na Symfony.",
            "details": [
              "Zdecydowałem się na Angular ze względu na jego wsparcie dla złożonych aplikacji",
              "Zaprojektowałem format JSON dla struktur formularzy",
              "Przemyślałem system zależności oparty na regułach warunkowych",
              "Przygotowałem dokumentację techniczną i diagramy przepływu danych"
            ]
          },
          {
            "id": "development",
            "title": "Faza Developmentu",
            "period": "Tydzień 5-14",
            "icon": "development",
            "description": "Główna faza implementacji zajęła około 10 tygodni. Zacząłem od podstawowych komponentów jak inputy i selecty, potem dodałem logikę drag & drop. Najtrudniejszym elementem było stworzenie silnika zależności - musiałem zaprojektować strukturę grafu, która pozwalała na definiowanie złożonych relacji między polami i ich dynamiczne odtwarzanie po stronie przeglądarki.",
            "details": [
              "Stworzyłem bibliotekę komponentów formularza (input, select, checkbox, radio, textarea)",
              "Zaimplementowałem mechanizm drag & drop oparty na Angular CDK",
              "Zaprojektowałem i zbudowałem silnik grafu zależności w TypeScript",
              "Silnik analizował strukturę JSON i budował graf połączeń między polami",
              "Na podstawie grafu dynamicznie przypisywał listenery i odtwarzał zachowania (show/hide, enable/disable, walidacje)",
              "Zoptymalizowałem traversowanie grafu żeby uniknąć cyklicznych zależności"
            ]
          },
          {
            "id": "testing",
            "title": "Testowanie",
            "period": "Tydzień 15-17",
            "icon": "testing",
            "description": "Przed wdrożeniem przeprowadziłem intensywne testy z rzeczywistymi użytkownikami. Zaprosiłem grupę redaktorów do testów beta, gdzie mogli tworzyć prawdziwe formularze i zgłaszać problemy. Dzięki ich feedbackowi poprawiłem wiele detali UX.",
            "details": [
              "Przeprowadziłem testy beta z 5 redaktorami z różnych spółek",
              "Naprawiłem błędy związane z walidacją i zapisywaniem stanu",
              "Zoptymalizowałem wydajność przy dużych formularzach",
              "Dodałem tooltips i podpowiedzi na podstawie feedbacku użytkowników"
            ]
          },
          {
            "id": "deployment",
            "title": "Wdrożenie",
            "period": "Tydzień 18-20",
            "icon": "deployment",
            "description": "Wdrożenie odbywało się etapami. Najpierw na środowisku testowym, potem na wybranych stronach grupy, a na końcu na wszystkich witrynach. Przeprowadziłem też szkolenia dla zespołów redakcyjnych, żeby mogli w pełni wykorzystać możliwości narzędzia.",
            "details": [
              "Wdrożyłem narzędzie na środowisko produkcyjne w trybie readonly",
              "Przeprowadziłem 3 sesje szkoleniowe dla zespołów redakcyjnych",
              "Monitorowałem metryki i zbierałem feedback po wdrożeniu",
              "Opracowałem dokumentację użytkownika i FAQ"
            ]
          }
        ]
      }
    },
    "gkpge-newsletter-pwa": {
      "title": "PGE Newsletter PWA",
      "tagline": "Aplikacja offline-first do newslettera wewnętrznego",
      "description": "Progressive Web App dla newslettera wewnętrznego Grupy Kapitalowej PGE, zaprojektowana z architekturą offline-first, Service Workers i stackiem React zorientowanym na wydajność, osiągając stały wynik Lighthouse 95+ dla performance i accessibility.",
      "overview": {
        "intro": "PGE Newsletter PWA to wewnętrzna aplikacja webowa służąca do dystrybucji wiadomości i aktualizacji w Grupie Kapitalowej PGE. Głównym celem było zapewnienie szybkiego ładowania, dostępu offline do treści oraz niezawodnego działania na urządzeniach z niestabilnym połączeniem sieciowym.",
        "goals": [
          "Zapewnienie dostępu offline-first do treści newslettera dla pracowników",
          "Osiągnięcie i utrzymanie wysokich wyników Lighthouse dla wydajności i dostępności (95+)",
          "Optymalizacja czasów ładowania przy niskiej przepustowości sieci",
          "Zapewnienie prostej, łatwej w utrzymaniu bazy kodu React do przyszłych rozszerzeń"
        ]
      },
      "features": [
        {
          "title": "Architektura Offline-first",
          "description": "Kluczowe widoki newslettera i zasoby cachowane przez Service Workers, aby użytkownicy mieli dostęp do treści bez połączenia sieciowego."
        },
        {
          "title": "Instalowalna PWA",
          "description": "Wsparcie dla funkcji dodawania do ekranu głównego na desktop i mobile, z konfiguracją manifestu i UX podobnym do aplikacji natywnych."
        },
        {
          "title": "Zoptymalizowana Wydajność",
          "description": "Code splitting, optymalizacja obrazów i strategie cachowania zaprojektowane w celu osiągnięcia stałego wyniku Lighthouse 95+."
        },
        {
          "title": "Dostępny Interfejs",
          "description": "Semantyczny HTML, nawigacja klawiaturą i atrybuty ARIA zgodnie z wewnętrznymi wymaganiami dostępności."
        }
      ],
      "techStack": {
        "frontend": [
          "React",
          "TypeScript",
          "React Router",
          "Styled Components / SCSS",
          "Lighthouse audits"
        ],
        "backend": [
          "REST API (wewnętrzne)",
          "Node.js lub istniejący backend PGE (warstwa integracji)",
          "Warstwa cachowania dla statycznych treści"
        ]
      },
      "highlights": [
        {
          "id": "offline-first-strategy",
          "title": "Strategia Offline-first z Service Workers",
          "problem": "Pracownicy potrzebowali dostępu do treści newslettera na urządzeniach z niestabilnym lub ograniczonym połączeniem, szczególnie w lokalizacjach terenowych.",
          "solution": "Implementacja Service Workera ze strategią cache-first dla statycznych zasobów i kluczowych widoków, z network-first dla dynamicznych treści, gdzie świeżość danych była ważna.",
          "impact": "Użytkownicy mogą otworzyć aplikację i czytać wcześniej załadowane newslettery nawet bez aktywnego połączenia, zmniejszając liczbę zgłoszeń do supportu związanych z problemami dostępu."
        },
        {
          "id": "lighthouse-optimisation",
          "title": "Lighthouse 95+ dla Performance i Accessibility",
          "problem": "Początkowe prototypy pokazywały niespójne wyniki wydajności i nie przechodziły testów dostępności.",
          "solution": "Iteracyjne audyty Lighthouse, optymalizacja obrazów i fontów, lazy loading dla modułów niekrytycznych oraz poprawki dostępności (etykiety, role, kontrast).",
          "impact": "Stabilne wyniki Lighthouse 95+ dla performance i accessibility w pipeline CI, dając zespołowi mierzalny benchmark jakości."
        },
        {
          "id": "background-refetch",
          "title": "Background Refetch z Fallbackiem dla iOS",
          "problem": "Użytkownicy potrzebowali świeżych treści newslettera gdy urządzenie wracało online, nawet jeśli aplikacja nie była aktywnie otwarta. Background Sync API działa na Androidzie, ale nie jest wspierane na iOS/Safari.",
          "solution": "Implementacja Background Sync API dla Androida z fallbackiem opartym na Workbox dla iOS. Na iOS wykorzystałem nasłuchiwanie na event online w połączeniu z aktywacją service workera, aby uruchomić refetch gdy użytkownik ponownie otwiera aplikację lub odblokowuje ekran.",
          "impact": "Użytkownicy Androida otrzymują prawdziwą synchronizację w tle gdy połączenie wraca. Użytkownicy iOS otrzymują automatyczne odświeżenie treści przy ponownym otwarciu aplikacji, zapewniając aktualne treści na wszystkich platformach pomimo ograniczeń API.",
          "code": {
            "registration": "// Rejestracja background sync (Android)\nconst registration = await navigator.serviceWorker.ready;\nawait registration.sync.register('newsletter-sync');\n\n// Listener w Service Workerze\nself.addEventListener('sync', event => {\n  if (event.tag === 'newsletter-sync') {\n    event.waitUntil(fetchLatestNewsletters());\n  }\n});",
            "iosFallback": "// Fallback dla iOS - wykrywanie online i trigger sync\nwindow.addEventListener('online', async () => {\n  if ('serviceWorker' in navigator) {\n    const registration = await navigator.serviceWorker.ready;\n    // Ręczne uruchomienie sync przez message\n    registration.active.postMessage({\n      type: 'MANUAL_SYNC',\n      tag: 'newsletter-sync'\n    });\n  }\n});\n\n// Service Worker - obsługa manual sync\nself.addEventListener('message', event => {\n  if (event.data.type === 'MANUAL_SYNC') {\n    event.waitUntil(fetchLatestNewsletters());\n  }\n});"
          }
        }
      ]
    }
  }
}
