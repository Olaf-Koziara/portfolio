{
  "nav": {
    "hero": "Start",
    "skills": "Umiejętności",
    "projects": "Projekty",
    "businessProjects": "Projekty Biznesowe",
    "experience": "Doświadczenie",
    "about": "O mnie",
    "contact": "Kontakt"
  },
  "hero": {
    "greeting": "Cześć, jestem",
    "name": "Olaf Koziara",
    "role": "Frontend Developer",
    "description": "Tworzę wydajne, dostępne aplikacje webowe z ponad 3-letnim doświadczeniem w ekosystemach React i Angular.",
    "cta": {
      "projects": "Zobacz Projekty",
      "cv": "Pobierz CV"
    }
  },
  "skills": {
    "title": "Technologie",
    "subtitle": "Narzędzia, z którymi pracuję"
  },
  "projects": {
    "title": "Wybrane Projekty",
    "subtitle": "Moje najnowsze prace",
    "viewLive": "Demo",
    "viewCode": "GitHub",
    "viewCaseStudy": "Case study",
    "items": [
      {
        "name": "Orbitask manager",
        "description": "Menedżer zadań z aktualizacjami w czasie rzeczywistym, drag & drop i funkcjami zespołowymi.",
        "stack": [
          "React",
          "TypeScript",
          "Tailwind",
          "Zustand",
          "Node.js",
          "MongoDB"
        ],
        "liveUrl": "https://example.com",
        "githubUrl": "https://github.com",
        "caseStudies": [
          {
            "title": ""
          }
        ]
      },
      {
        "name": "Angular finance",
        "description": "Współdzielony menedżer zadań z aktualizacjami w czasie rzeczywistym, drag & drop i funkcjami zespołowymi.",
        "stack": ["React", "Node.js", "Socket.io", "MongoDB"],
        "liveUrl": "https://example.com",
        "githubUrl": "https://github.com"
      },
      {
        "name": "Dashboard Pogodowy",
        "description": "Piękna aplikacja pogodowa z prognozami, mapami i wyszukiwaniem lokalizacji zasilana przez API pogodowe.",
        "stack": ["Next.js", "TypeScript", "Chart.js", "Leaflet"],
        "liveUrl": "https://example.com",
        "githubUrl": "https://github.com"
      },
      {
        "name": "CMS Portfolio",
        "description": "Headless CMS do zarządzania treścią portfolio z niestandardowymi polami i biblioteką mediów.",
        "stack": ["Angular", "NestJS", "PostgreSQL", "AWS"],
        "liveUrl": "https://example.com",
        "githubUrl": "https://github.com"
      }
    ]
  },
  "businessProjects": {
    "title": "Projekty Biznesowe",
    "subtitle": "Realizacje dla duzych organizacji i korporacji",
    "client": "Klient",
    "year": "Okres",
    "scopeOfWork": "Zakres prac",
    "viewCaseStudy": "Zobacz case study",
    "items": [
      {
        "id": "gkpge-cms",
        "name": "Motyw i komponenty CMS dla Grupy PGE",
        "client": "Grupa Kapitalowa PGE",
        "year": "2021-2023",
        "description": "Stworzenie nowego, nowoczesnego motywu oraz zestawu wielokrotnego uzytku komponentow dla systemu CMS Grupy PGE. Glownym celem byla aktualizacja identyfikacji wizualnej stron grupy przy jednoczesnym usprawnieniu procesu zarzadzania i utrzymania.",
        "scope": ["Web Design", "Web Development", "TWIG", "SCSS", "JavaScript"]
      },
      {
        "id": "gkpge-formbuilder",
        "name": "FormBuilder dla wewnetrznego CMS",
        "client": "PGE Systemy",
        "year": "2021-2023",
        "description": "Narzedzie do budowania formularzy zintegrowane z platforma CMS firmy, przeznaczone do tworzenia stron w ramach grupy kapitalowej. Panel FormBuildera zostal oparty na Angularze z TypeScriptem i zintegrowany z backendem Symfony/Twig.",
        "scope": ["Angular", "TypeScript", "RxJS", "TWIG", "SCSS"]
      }
    ]
  },
  "experience": {
    "title": "Doświadczenie",
    "subtitle": "Moja zawodowa podróż",
    "items": [
      {
        "company": "SunGroup",
        "role": "Frontend Developer",
        "period": "Kwi 2025 - Lip 2025",
        "points": [
          "Tworzyłem bibliotekę reużywalnych komponentów webowych (PHP, JS, CSS) w pełni zgodnych z WCAG 2.2",
          "Wdrożyłem dostępne komponenty na ponad 100 landing pages zapewniając spójność",
          "Ściśle współpracowałem z UI/UX designerami przy implementacji pixel-perfect interfejsów"
        ]
      },
      {
        "company": "PGE Systemy",
        "role": "Frontend Developer",
        "period": "Lip 2021 - Wrz 2024",
        "points": [
          "Rozwijałem aplikacje w ekosystemach React i Angular dla Grupy PGE",
          "PWA Newsletter: Zaimplementowałem offline-first z Service Workers, osiągając Lighthouse 95+",
          "Aplikacja Raportowania Finansowego: Zaprojektowałem Next.js z GraphQL API obsługującym 1000+ zapytań dziennie",
          "CMS FormBuilder: Zbudowałem dynamiczne formularze z zależnościami pól używane w całej grupie kapitałowej",
          "Core Theme: Zaprojektowałem reużywalne komponenty TWIG/SASS/JS dla wszystkich stron GK PGE"
        ]
      },
      {
        "company": "Freelance",
        "role": "Fullstack Developer",
        "period": "Mar 2022 - Obecnie",
        "points": [
          "Customizacja rozwiązań Comarch B2B z wykorzystaniem Angular na frontendzie i C#/.NET/SQL na backendzie",
          "Rozwój aplikacji WordPress i Next.js z bezpieczną integracją bramek płatności",
          "Optymalizacja SEO legacy websites — wzrost ruchu organicznego o ponad 30%",
          "Stworzenie pluginu osTicket do automatycznej migracji ticketów do Redmine"
        ]
      }
    ]
  },
  "about": {
    "title": "O Mnie",
    "subtitle": "Trochę więcej o tym, kim jestem",
    "paragraphs": [
      "Frontend developer z ponad 3-letnim doświadczeniem komercyjnym. Specjalizuję się w React, ale swobodnie poruszam się również w ekosystemie Angular oraz technologiach backendowych. Ta wszechstronność pozwala mi efektywnie współpracować z różnymi zespołami i podejmować się złożonych projektów.",
      "W swojej karierze dostarczałem rozwiązania dla dużych organizacji — od Progressive Web Apps z wynikiem Lighthouse 95+ po systemy formularzy obsługujące całe korporacje. Cenię czysty kod, dostępność i wydajność.",
      "Chętnie dzielę się wiedzą i nieustannie poszerzam swoje kompetencje. Jeśli szukasz kogoś, kto podejdzie do projektu z zaangażowaniem — porozmawiajmy."
    ]
  },
  "contact": {
    "title": "Skontaktuj się",
    "subtitle": "Pracujmy razem",
    "email": "Wyślij Email",
    "form": {
      "name": "Imię",
      "email": "Email",
      "message": "Wiadomość",
      "send": "Wyślij Wiadomość"
    }
  },
  "footer": {
    "rights": "Wszelkie prawa zastrzeżone."
  },
  "caseStudy": {
    "backToProjects": "Powrot do Projektow",
    "overview": "Przeglad",
    "techStack": "Stack Technologiczny",
    "keyFeatures": "Kluczowe Funkcje",
    "technicalHighlights": "Aspekty Techniczne",
    "demoAccount": "Konto Demo",
    "processTitle": "Proces Realizacji",
    "processSubtitle": "Od pierwszych rozmow do wdrozenia na produkcje",
    "visualComparison": "Porownanie Wizualne",
    "orbitaskmanager": {
      "title": "OrbiTask Manager",
      "tagline": "Nowoczesne Zarzadzanie Zadaniami i Projektami",
      "description": "Kompleksowa aplikacja do zarzadzania zadaniami i projektami, zaprojektowana w celu zwiekszenia produktywnosci poprzez inteligentna organizacje, wizualne przeplywy pracy i plynna wspolprace.",
      "demoUrl": "https://orbitask-manager-1.onrender.com/",
      "demoCredentials": {
        "email": "test@gmail.com",
        "password": "12test34"
      },
      "overview": {
        "intro": "OrbiTask Manager to gotowa do produkcji aplikacja full-stack, ktora demonstruje nowoczesne praktyki tworzenia aplikacji webowych. Zbudowana jako narzedzie do zwiekszania produktywnosci, laczy potezne technologie z intuicyjnym interfejsem uzytkownika.",
        "goals": [
          "Usprawnienie zarzadzania zadaniami i planowania projektow",
          "Implementacja skalowalnej architektury dla rosnacej zlozonosci",
          "Stworzenie intuicyjnego interfejsu z wieloma trybami widoku",
          "Budowa modularnego designu ulatwiajacego dodawanie funkcji"
        ]
      },
      "features": [
        {
          "title": "Wiele Trybow Widoku",
          "description": "Tablica Kanban, widok Kalendarza i Lista dla roznych przeplywow pracy"
        },
        {
          "title": "System Priorytetow",
          "description": "Klasyfikacja priorytetow: Niski, Sredni, Wysoki i Pilny"
        },
        {
          "title": "Aktualizacje w Czasie Rzeczywistym",
          "description": "Synchronizacja na zywo miedzy wszystkimi polaczonymi urzadzeniami"
        },
        {
          "title": "Przeciagnij i Upusc",
          "description": "Intuicyjne zarzadzanie zadaniami z plynnym przeciaganiem"
        },
        {
          "title": "Wspolpraca Zespolowa",
          "description": "Przypisywanie zadan, udostepnianie projektow i wspolna praca"
        },
        {
          "title": "Zaawansowane Filtrowanie",
          "description": "Filtruj wedlug projektu, osoby przypisanej, priorytetu i wiecej"
        }
      ],
      "techStack": {
        "frontend": [
          "React 18",
          "TypeScript",
          "Vite",
          "Tailwind CSS",
          "Shadcn/ui",
          "React Query",
          "Zustand"
        ],
        "backend": [
          "Node.js",
          "Express.js",
          "tRPC",
          "MongoDB",
          "Mongoose",
          "JWT",
          "Zod"
        ]
      },
      "highlights": [
        {
          "id": "type-safety",
          "title": "Magia Bezpieczenstwa Typow End-to-End",
          "problem": "W tradycyjnych REST API, gdy zmienisz pole na backendzie, frontend dowiaduje sie o tym dopiero gdy wystapie bledy w czasie wykonania.",
          "solution": "Uzycie tRPC do automatycznej synchronizacji typow miedzy frontendem a backendem bez generowania kodu.",
          "impact": "Zero bledow typow w czasie wykonania, natychmiastowy refactoring w calym stacku, autocomplete wszedzie.",
          "code": {
            "backend": "export const taskRouter = router({\n  create: protectedProcedure\n    .input(z.object({\n      title: z.string().min(1).max(100),\n      priority: z.enum(['low', 'medium', 'high', 'urgent']),\n      dueDate: z.date().optional(),\n    }))\n    .mutation(async ({ input, ctx }) => {\n      return await TaskModel.create({\n        ...input,\n        createdBy: ctx.user.id,\n      });\n    }),\n});",
            "frontend": "export const useTasks = () => {\n  const createTask = trpc.tasks.create.useMutation();\n  \n  // TypeScript ZNA WSZYSTKO o tym API\n  createTask.mutate({\n    title: \"Nowe zadanie\",\n    priority: \"high\",\n    dueDate: new Date('2026-02-01'),\n  });\n};"
          }
        },
        {
          "id": "drag-drop",
          "title": "Kanban z Przeciaganiem i Klikalnym Przyciskami",
          "problem": "Standardowe przeciaganie blokuje WSZYSTKIE klikniecia podczas przeciagania. Nie mozna kliknac przycisku Usun wewnatrz przeciaganej karty.",
          "solution": "Niestandardowy sensor wykrywajacy atrybut data-no-dnd, pozwalajacy na interaktywne elementy wewnatrz przeciaganych kart.",
          "impact": "Uzytkownicy moga plynnie przeciagac karty ORAZ klikac przyciski w ich wnetrzu. Najlepsze z obu swiatow!",
          "code": {
            "sensor": "export class CustomSensor extends PointerSensor {\n  static activators = [{\n    eventName: 'onPointerDown' as const,\n    handler: ({nativeEvent: event}) => {\n      let element = event.target as HTMLElement;\n      while (element) {\n        if (element.dataset?.noDnd) {\n          return false;\n        }\n        element = element.parentElement;\n      }\n      return true;\n    }\n  }];\n}",
            "usage": "export const TaskCard = ({ task }) => (\n  <div className=\"task-card\">\n    <h3>{task.title}</h3>\n    <div className=\"actions\" data-no-dnd>\n      <Button onClick={handleEdit}>\n        <PencilIcon /> Edytuj\n      </Button>\n      <Button onClick={handleDelete}>\n        <TrashIcon /> Usun\n      </Button>\n    </div>\n  </div>\n);"
          }
        },
        {
          "id": "optimistic-updates",
          "title": "Optymistyczne Aktualizacje z Cofnieciem",
          "problem": "Uzytkownik klika 'Oznacz jako Wykonane' -> czeka 500ms na API -> w koncu widzi zmiane. Czuje sie wolno.",
          "solution": "Natychmiastowa aktualizacja UI (optymistycznie), synchronizacja z backendem w tle, automatyczne cofniecie przy bledach.",
          "impact": "Aplikacja dziala blyskawicznie. Nie czekamy na API. Automatyczne cofniecie przy bledach.",
          "code": {
            "implementation": "export const useTasks = () => {\n  const updateTaskStatus = useCallback(\n    async (taskId: string, newStatus: TaskStatus) => {\n      const originalTasks = [...tasks];\n      \n      const optimisticTasks = tasks.map(task =>\n        task._id === taskId ? { ...task, status: newStatus } : task\n      );\n      setTasks(optimisticTasks);\n      \n      try {\n        await utils.client.tasks.update.mutate({\n          id: taskId,\n          data: { status: newStatus },\n        });\n        \n        await utils.tasks.invalidate();\n      } catch (error) {\n        setTasks(originalTasks);\n        toast.error(\"Nie udalo sie zaktualizowac zadania.\");\n      }\n    },\n    [tasks, utils]\n  );\n};"
          }
        },
        {
          "id": "debouncing",
          "title": "Inteligentne Debouncing dla Wyszukiwania",
          "problem": "Uzytkownik wpisuje 'implementacja autentykacji' w wyszukiwarke -> 28 znakow = 28 zapytan API w 2 sekundy!",
          "solution": "Niestandardowy hook debounce, ktory czeka 300ms po tym jak uzytkownik przestanie pisac przed wyslaniem zapytania.",
          "impact": "28 zapytan -> 1 zapytanie. Znacznie szczesliwszy serwer API!",
          "code": {
            "hook": "export function useDebounce<T>(value: T, delay: number): T {\n  const [debouncedValue, setDebouncedValue] = useState<T>(value);\n\n  useEffect(() => {\n    const handler = setTimeout(() => {\n      setDebouncedValue(value);\n    }, delay);\n\n    return () => clearTimeout(handler);\n  }, [value, delay]);\n\n  return debouncedValue;\n}",
            "usage": "export const useTasks = () => {\n  const { taskFilters } = useFiltersStore();\n  \n  const debouncedFilters = useDebounce(taskFilters, 300);\n  \n  const queryInput = useMemo(\n    () => FilterService.prepareQueryFilters(debouncedFilters),\n    [debouncedFilters]\n  );\n  \n  const { data: tasks } = trpc.tasks.list.useQuery(queryInput, {\n    staleTime: 30000,\n  });\n};"
          }
        },
        {
          "id": "performance",
          "title": "Mistrzowska Optymalizacja Wydajnosci",
          "problem": "Lista 50 kart zadan renderuje sie calkowicie przy kazdej zmianie stanu rodzica, nawet jesli zadania sie nie zmienily.",
          "solution": "Strategiczne uzycie useMemo, useCallback i React.memo aby zapobiec niepotrzebnym re-renderom.",
          "impact": "O 73% szybsze renderowanie! Z 450ms do 120ms dla 50 zadan.",
          "code": {
            "optimized": "export const KanbanBoard = () => {\n  const { tasks } = useTasks();\n  \n  const tasksByStatus = useMemo(() => {\n    return COLUMNS.reduce((acc, col) => {\n      acc[col.status] = tasks.filter(t => t.status === col.status);\n      return acc;\n    }, {} as Record<TaskStatus, Task[]>);\n  }, [tasks]);\n  \n  const handleDragEnd = useCallback((event: DragEndEvent) => {\n    const taskId = event.active.id as string;\n    const newStatus = event.over.id as TaskStatus;\n    setTaskStatus(taskId, newStatus);\n  }, [setTaskStatus]);\n  \n  return (\n    <DndContext onDragEnd={handleDragEnd}>\n      {COLUMNS.map(col => (\n        <Column \n          key={col.status}\n          tasks={tasksByStatus[col.status]}\n        />\n      ))}\n    </DndContext>\n  );\n};"
          }
        }
      ]
    },
    "gkpge-cms": {
      "title": "Motyw CMS dla Grupy PGE",
      "tagline": "Nowoczesny system komponentow dla korporacyjnego CMS",
      "description": "Zaprojektowanie i wdrozenie nowego motywu oraz biblioteki komponentow wielokrotnego uzytku dla systemu zarzadzania trescia Grupy Kapitalowej PGE. Projekt objal odswiezenie identyfikacji wizualnej przy zachowaniu spojnosci na wszystkich stronach grupy.",
      "overview": {
        "intro": "Grupa Kapitalowa PGE to najwieksza polska firma energetyczna, posiadajaca kilkadziesiat stron internetowych zarzadzanych przez wewnetrzny CMS. Moim zadaniem bylo stworzenie nowego, spolnego motywu wizualnego oraz zestawu komponentow, ktore moga byc uzywane przez wszystkie strony w grupie.",
        "goals": [
          "Odswiezenie identyfikacji wizualnej zgodnie z nowym brandingiem",
          "Stworzenie biblioteki komponentow wielokrotnego uzytku",
          "Usprawnienie procesu tworzenia nowych stron",
          "Zapewnienie spojnosci wizualnej na wszystkich witrynach grupy"
        ]
      },
      "features": [
        {
          "title": "System Komponentow",
          "description": "Ponad 40 komponentow wielokrotnego uzytku od przyciskow po zlozone layouty"
        },
        {
          "title": "Responsywnosc",
          "description": "Pelna responsywnosc na wszystkich urzadzeniach od mobile po desktop"
        },
        {
          "title": "Dostepnosc",
          "description": "Zgodnosc z WCAG 2.1 dla zapewnienia dostepnosci dla wszystkich uzytkownikow"
        },
        {
          "title": "Dokumentacja",
          "description": "Szczegolowa dokumentacja kazdego komponentu z przykladami uzycia"
        },
        {
          "title": "Skalowalnosc",
          "description": "Architektura umozliwiajaca latwe dodawanie nowych komponentow"
        },
        {
          "title": "Wydajnosc",
          "description": "Zoptymalizowany kod CSS i JS dla szybkiego ladowania stron"
        }
      ],
      "techStack": {
        "frontend": [
          "TWIG",
          "SCSS",
          "JavaScript ES6+",
          "BEM",
          "CSS Grid",
          "Flexbox"
        ],
        "backend": [
          "Symfony",
          "PHP",
          "MySQL",
          "Doctrine ORM"
        ]
      },
      "comparison": {
        "title": "Transformacja Wizualna",
        "beforeLabel": "Przed",
        "afterLabel": "Po"
      }
    },
    "gkpge-formbuilder": {
      "title": "FormBuilder dla CMS PGE",
      "tagline": "Narzedzie do budowania dynamicznych formularzy",
      "description": "Kompleksowe narzedzie do tworzenia formularzy z interfejsem drag & drop, obsluga zaleznosci miedzy polami oraz mozliwoscia definiowania niestandardowych akcji po wyslaniu. FormBuilder zostal zintegrowany z wewnetrznym CMS grupy kapitalowej.",
      "overview": {
        "intro": "FormBuilder to narzedzie pozwalajace redaktorom tresci na tworzenie zlozonych formularzy bez udzialu programistow. Panel administracyjny oparty na Angularze umozliwia wizualne projektowanie formularzy, ktore nastepnie sa eksportowane jako JSON i renderowane przez backend Symfony. Po stronie przegladarki stworzylem dedykowany silnik w TypeScript, ktory na podstawie grafu zaleznosci odtwarza wszystkie dynamiczne zachowania zdefiniowane w builderze.",
        "goals": [
          "Umozliwienie redaktorom samodzielnego tworzenia formularzy",
          "Implementacja systemu zaleznosci miedzy polami",
          "Stworzenie intuicyjnego interfejsu drag & drop",
          "Zapewnienie pelnej walidacji po stronie klienta i serwera",
          "Budowa silnika grafu zaleznosci do odtwarzania dynamicznych zachowan"
        ]
      },
      "features": [
        {
          "title": "Drag & Drop",
          "description": "Intuicyjne przeciaganie komponentow formularza na canvas"
        },
        {
          "title": "Zaleznosci Pol",
          "description": "Definiowanie warunkow pokazywania i ukrywania pol"
        },
        {
          "title": "Silnik Grafu Zaleznosci",
          "description": "Dedykowany silnik TypeScript odtwarzajacy zaleznosci na podstawie grafu polaczen miedzy polami"
        },
        {
          "title": "Niestandardowe Akcje",
          "description": "Konfiguracja zachowania po wyslaniu formularza"
        },
        {
          "title": "Walidacja",
          "description": "Walidacja w czasie rzeczywistym po stronie klienta"
        },
        {
          "title": "Eksport JSON",
          "description": "Struktura formularza eksportowana do JSON dla backendu"
        }
      ],
      "techStack": {
        "frontend": [
          "Angular 12+",
          "TypeScript",
          "RxJS",
          "Angular CDK",
          "SCSS"
        ],
        "backend": [
          "Symfony",
          "TWIG",
          "PHP",
          "MySQL"
        ]
      },
      "process": {
        "title": "Proces Realizacji Projektu",
        "subtitle": "Od pierwszych rozmow z biznesem do wdrozenia na produkcje",
        "steps": [
          {
            "id": "discovery",
            "title": "Rozmowy z Biznesem",
            "period": "Tydzien 1-2",
            "icon": "discovery",
            "description": "Projekt zaczal sie od serii spotkan z zespolem biznesowym i redaktorami tresci. Chcialem zrozumiec ich codzienne problemy i frustracje zwiazane z obecnym procesem tworzenia formularzy. Okazalo sie, ze kazdy nowy formularz wymaga zgloszen do IT i czekania nawet kilka tygodni na realizacje.",
            "details": [
              "Przeprowadzilem wywiady z 8 redaktorami tresci z roznych spolek grupy",
              "Zidentyfikowalem glowny problem - zbyt dlugi czas od pomyslu do publikacji formularza",
              "Zebralem wymagania dotyczace typow pol i zaleznosci miedzy nimi",
              "Ustalilem priorytety funkcjonalnosci z product ownerem"
            ]
          },
          {
            "id": "planning",
            "title": "Planowanie Architektury",
            "period": "Tydzien 3-4",
            "icon": "planning",
            "description": "Po zebraniu wymagan przyszedl czas na zaprojektowanie architektury systemu. Musialem podjac kilka kluczowych decyzji technicznych - jak przechowywac strukture formularza, jak obslugiwac zaleznosci miedzy polami i jak zintegrować narzedzie z istniejacym CMS opartym na Symfony.",
            "details": [
              "Zdecydowalem sie na Angular ze wzgledu na jego wsparcie dla zlozonych aplikacji",
              "Zaprojektowalem format JSON dla struktur formularzy",
              "Przemyslalem system zaleznosci oparty na regułach warunkowych",
              "Przygotowalem dokumentacje techniczna i diagramy przepływu danych"
            ]
          },
          {
            "id": "development",
            "title": "Faza Developmentu",
            "period": "Tydzien 5-14",
            "icon": "development",
            "description": "Glowna faza implementacji zajela okolo 10 tygodni. Zaczalem od podstawowych komponentow jak inputy i selecty, potem dodalem logike drag & drop. Najtrudniejszym elementem bylo stworzenie silnika zaleznosci - musialem zaprojektowac strukture grafu, ktora pozwalala na definiowanie zlozonych relacji miedzy polami i ich dynamiczne odtwarzanie po stronie przegladarki.",
            "details": [
              "Stworzylem biblioteke komponentow formularza (input, select, checkbox, radio, textarea)",
              "Zaimplementowalem mechanizm drag & drop oparty na Angular CDK",
              "Zaprojektowalem i zbudowalem silnik grafu zaleznosci w TypeScript",
              "Silnik analizowal strukture JSON i budowal graf polaczen miedzy polami",
              "Na podstawie grafu dynamicznie przypisywal listenery i odtwarzal zachowania (show/hide, enable/disable, walidacje)",
              "Zoptymalizowalem traversowanie grafu zeby uniknac cyklicznych zaleznosci"
            ]
          },
          {
            "id": "testing",
            "title": "Testowanie",
            "period": "Tydzien 15-17",
            "icon": "testing",
            "description": "Przed wdrozeniem przeprowadzilem intensywne testy z rzeczywistymi uzytkownikami. Zaprosłlem grupę redaktorów do testów beta, gdzie mogli tworzyc prawdziwe formularze i zgłaszac problemy. Dzieki ich feedbackowi poprawiłem wiele detali UX.",
            "details": [
              "Przeprowadzilem testy beta z 5 redaktorami z roznych spolek",
              "Naprawilem bledy zwiazane z walidacja i zapisywaniem stanu",
              "Zoptymalizowalem wydajnosc przy duzych formularzach",
              "Dodałem tooltips i podpowiedzi na podstawie feedbacku uzytkownikow"
            ]
          },
          {
            "id": "deployment",
            "title": "Wdrozenie",
            "period": "Tydzien 18-20",
            "icon": "deployment",
            "description": "Wdrozenie odbywalo sie etapami. Najpierw na srodowisku testowym, potem na wybranych stronach grupy, a na koncu na wszystkich witrynach. Przeprowadzilem tez szkolenia dla zespolow redakcyjnych, zeby mogli w pelni wykorzystac mozliwosci narzedzia.",
            "details": [
              "Wdrozylem narzedzie na srodowisko produkcyjne w trybie readonly",
              "Przeprowadzilem 3 sesje szkoleniowe dla zespolow redakcyjnych",
              "Monitorowalem metryki i zbieralem feedback po wdrozeniu",
              "Opracowalem dokumentację uzytkownika i FAQ"
            ]
          }
        ]
      }
    }
  }
}
