{
  "common": {
    "themeToggle": {
      "ariaLabel": "Toggle theme",
      "switchToDark": "Switch to dark theme",
      "switchToLight": "Switch to light theme"
    },
    "languageSwitcher": {
      "ariaLabel": "Select language",
      "en": "English",
      "pl": "Polish",
      "switchToEn": "Switch to English",
      "switchToPl": "Switch to Polish"
    }
  },
  "nav": {
    "hero": "Home",
    "skills": "Skills",
    "projects": "Projects",
    "businessProjects": "Business Projects",
    "experience": "Experience",
    "about": "About",
    "contact": "Contact"
  },
  "hero": {
    "greeting": "Hi, I'm",
    "name": "Olaf Koziara",
    "role": "Frontend Developer",
    "description": "Building scalable web applications with React and Angular. 3+ years of commercial experience, focused on performance and accessibility.",
    "cta": {
      "projects": "View Projects",
      "cv": "Download CV"
    }
  },
  "skills": {
    "title": "Technologies",
    "subtitle": "Tools I work with"
  },
  "projects": {
    "title": "Featured Projects",
    "subtitle": "My recent work",
    "viewLive": "Live Demo",
    "viewCode": "GitHub",
    "viewCaseStudy": "Case study",
    "items": [
      {
        "name": "Orbitask manager",
        "description": "Task manager with real-time sync, drag & drop, and team collaboration features.",
        "stack": [
          "React",
          "TypeScript",
          "Tailwind",
          "Zustand",
          "Node.js",
          "MongoDB"
        ],
        "liveUrl": "https://orbitask.olafwebdev.site/",
        "githubUrl": "https://github.com/Olaf-Koziara/orbitask-manager",
        "caseStudies": [
          {
            "title": ""
          }
        ]
      },
      {
        "name": "Angular finance",
        "description": "Finance management app with dashboard and data visualization.",
        "stack": ["Angular", "TypeScript", "RxJS", "Node.js"],
        "liveUrl": "https://example.com",
        "githubUrl": "https://github.com"
      }
    ]
  },
  "businessProjects": {
    "title": "Business Projects",
    "subtitle": "Enterprise and corporate implementations",
    "client": "Client",
    "year": "Period",
    "scopeOfWork": "Scope of Work",
    "viewCaseStudy": "View case study",
    "items": [
      {
        "id": "gkpge-formbuilder",
        "name": "FormBuilder for Internal CMS",
        "client": "PGE Systemy",
        "year": "2021-2023",
        "description": "Form-building tool integrated with the CMS platform. Panel built with Angular and TypeScript, integrated with Symfony/Twig backend.",
        "scope": ["Angular", "TypeScript", "RxJS", "TWIG", "SCSS"]
      },
      {
        "id": "gkpge-cms",
        "name": "CMS Theme and Components for PGE Group",
        "client": "PGE Capital Group",
        "year": "2021-2023",
        "description": "Created a new theme and reusable component library for PGE Group's CMS. The project included unifying visual identity and streamlining content management processes.",
        "scope": ["Web Design", "Web Development", "TWIG", "SCSS", "JavaScript"]
      },

      {
        "id": "gkpge-newsletter-pwa",
        "name": "PGE Newsletter (PWA / Offline-first)",
        "client": "PGE Capital Group",
        "year": "2022-2023",
        "description": "Progressive Web App for internal newsletter distribution with offline-first architecture, Service Workers and performance-focused React implementation, achieving consistent Lighthouse scores of 95+ for performance and accessibility.",
        "scope": [
          "React",
          "TypeScript",
          "PWA",
          "Service Workers",
          "Lighthouse",
          "Accessibility"
        ]
      }
    ]
  },
  "experience": {
    "title": "Experience",
    "subtitle": "My professional journey",
    "items": [
      {
        "company": "SunGroup",
        "role": "Frontend Developer",
        "period": "Apr 2025 - Jul 2025",
        "points": [
          "Developed a library of reusable web components (PHP, JS, CSS) fully compliant with WCAG 2.2",
          "Library deployed across 100+ landing pages, ensuring visual consistency and accessibility",
          "Collaborated with UI/UX team on pixel-perfect interface implementations"
        ]
      },
      {
        "company": "PGE Systemy",
        "role": "Frontend Developer",
        "period": "Jul 2021 - Sep 2024",
        "points": [
          "Built web applications in React and Angular for Poland's largest energy company",
          "PWA Newsletter — implemented offline-first with Service Workers, achieving Lighthouse score 95+",
          "Financial Reporting App — built Next.js solution with GraphQL API handling 1000+ queries daily",
          "CMS Form Builder — designed dynamic form system with field dependencies, used across the entire capital group",
          "Core Theme — created reusable component library (TWIG/SASS/JS) for all PGE Group websites"
        ]
      },
      {
        "company": "Freelance",
        "role": "Fullstack Developer",
        "period": "Mar 2022 - Present",
        "points": [
          "Customization of Comarch B2B solutions — Angular frontend, C#/.NET/SQL backend",
          "Built WordPress and Next.js applications with payment gateway integrations",
          "SEO optimization for legacy websites — increased organic traffic by over 30%",
          "Workflow automation — osTicket plugin for ticket migration to Redmine"
        ]
      }
    ]
  },
  "about": {
    "title": "About Me",
    "subtitle": "A bit more about who I am",
    "paragraphs": [
      "Frontend developer with 3+ years of commercial experience, specializing in React and Angular. Additionally, I learn and use Node.js in projects, which allows me to collaborate effectively with backend teams and understand the full application lifecycle.",
      "I've worked on applications for large organizations — from advanced form builders serving hundreds of users to responsive PWAs with Lighthouse scores of 95+. I deliver solutions that work, have clean code, and are pleasant to use.",
      "I enjoy diving into application architecture, experimenting with new technologies, and sharing knowledge with others. If you're looking for someone who approaches projects with genuine commitment and isn't afraid of technical challenges — let's talk."
    ]
  },
  "contact": {
    "title": "Get in Touch",
    "subtitle": "Let's work together",
    "email": "Send Email",
    "form": {
      "name": "Name",
      "email": "Email",
      "message": "Message",
      "send": "Send Message"
    }
  },
  "footer": {
    "rights": "All rights reserved."
  },
  "caseStudy": {
    "backToProjects": "Back to Projects",
    "overview": "Overview",
    "techStack": "Tech Stack",
    "keyFeatures": "Key Features",
    "technicalHighlights": "Technical Highlights",
    "demoAccount": "Demo Account",
    "processTitle": "Implementation Process",
    "processSubtitle": "From initial discussions to production deployment",
    "visualComparison": "Visual Comparison",
    "orbitaskmanager": {
      "title": "OrbiTask Manager",
      "tagline": "Task and Project Management",
      "description": "Task and project management application designed to increase productivity through intelligent organization, visual workflows, and collaboration.",
      "demoUrl": "https://orbitask-manager-1.onrender.com/",
      "demoCredentials": {
        "email": "test@gmail.com",
        "password": "12test34"
      },
      "overview": {
        "intro": "OrbiTask Manager is a full-stack application demonstrating modern web development practices. Built as a productivity tool, it combines powerful technologies with an intuitive user interface.",
        "goals": [
          "Streamline task management and project planning",
          "Implement scalable architecture for growing complexity",
          "Create an intuitive interface with multiple view modes",
          "Build a modular design that facilitates adding features"
        ]
      },
      "features": [
        {
          "title": "Multiple View Modes",
          "description": "Kanban board, Calendar view, and List for different workflows"
        },
        {
          "title": "Priority System",
          "description": "Priority classification: Low, Medium, High, and Urgent"
        },
        {
          "title": "Real-time Sync",
          "description": "Live updates across all connected devices"
        },
        {
          "title": "Drag & Drop",
          "description": "Intuitive task management with smooth dragging"
        },
        {
          "title": "Team Collaboration",
          "description": "Task assignment, project sharing, and teamwork"
        },
        {
          "title": "Advanced Filtering",
          "description": "Filter by project, assignee, priority, and more"
        }
      ],
      "techStack": {
        "frontend": [
          "React 18",
          "TypeScript",
          "Vite",
          "Tailwind CSS",
          "Shadcn/ui",
          "React Query",
          "Zustand"
        ],
        "backend": [
          "Node.js",
          "Express.js",
          "tRPC",
          "MongoDB",
          "Mongoose",
          "JWT",
          "Zod"
        ]
      },
      "highlights": [
        {
          "id": "type-safety",
          "title": "End-to-End Type Safety",
          "problem": "In traditional REST APIs, when you change a field on the backend, the frontend only learns about it when runtime errors occur.",
          "solution": "Using tRPC for automatic type synchronization between frontend and backend without code generation.",
          "impact": "Zero type errors at runtime, instant refactoring across the entire stack, autocomplete everywhere.",
          "code": {
            "backend": "export const taskRouter = router({\n  create: protectedProcedure\n    .input(z.object({\n      title: z.string().min(1).max(100),\n      priority: z.enum(['low', 'medium', 'high', 'urgent']),\n      dueDate: z.date().optional(),\n    }))\n    .mutation(async ({ input, ctx }) => {\n      return await TaskModel.create({\n        ...input,\n        createdBy: ctx.user.id,\n      });\n    }),\n});",
            "frontend": "export const useTasks = () => {\n  const createTask = trpc.tasks.create.useMutation();\n  \n  // TypeScript KNOWS EVERYTHING about this API\n  createTask.mutate({\n    title: \"New task\",\n    priority: \"high\",\n    dueDate: new Date('2026-02-01'),\n  });\n};"
          }
        },
        {
          "id": "drag-drop",
          "title": "Kanban with Drag & Clickable Buttons",
          "problem": "Standard dragging blocks ALL clicks during drag. You can't click the Delete button inside a dragged card.",
          "solution": "Custom sensor detecting data-no-dnd attribute, allowing interactive elements inside dragged cards.",
          "impact": "Users can smoothly drag cards AND click buttons inside them.",
          "code": {
            "sensor": "export class CustomSensor extends PointerSensor {\n  static activators = [{\n    eventName: 'onPointerDown' as const,\n    handler: ({nativeEvent: event}) => {\n      let element = event.target as HTMLElement;\n      while (element) {\n        if (element.dataset?.noDnd) {\n          return false;\n        }\n        element = element.parentElement;\n      }\n      return true;\n    }\n  }];\n}",
            "usage": "export const TaskCard = ({ task }) => (\n  <div className=\"task-card\">\n    <h3>{task.title}</h3>\n    <div className=\"actions\" data-no-dnd>\n      <Button onClick={handleEdit}>\n        <PencilIcon /> Edit\n      </Button>\n      <Button onClick={handleDelete}>\n        <TrashIcon /> Delete\n      </Button>\n    </div>\n  </div>\n);"
          }
        },
        {
          "id": "optimistic-updates",
          "title": "Optimistic Updates with Rollback",
          "problem": "User clicks 'Mark as Done' → waits 500ms for API → finally sees change. Feels slow.",
          "solution": "Immediate UI update (optimistically), backend sync in background, automatic rollback on errors.",
          "impact": "App feels instant. No waiting for API. Automatic rollback on errors.",
          "code": {
            "implementation": "export const useTasks = () => {\n  const updateTaskStatus = useCallback(\n    async (taskId: string, newStatus: TaskStatus) => {\n      const originalTasks = [...tasks];\n      \n      const optimisticTasks = tasks.map(task =>\n        task._id === taskId ? { ...task, status: newStatus } : task\n      );\n      setTasks(optimisticTasks);\n      \n      try {\n        await utils.client.tasks.update.mutate({\n          id: taskId,\n          data: { status: newStatus },\n        });\n        \n        await utils.tasks.invalidate();\n      } catch (error) {\n        setTasks(originalTasks);\n        toast.error(\"Failed to update task.\");\n      }\n    },\n    [tasks, utils]\n  );\n};"
          }
        },
        {
          "id": "debouncing",
          "title": "Smart Debouncing for Search",
          "problem": "User types 'authentication implementation' in search → 28 characters = 28 API requests in 2 seconds!",
          "solution": "Custom debounce hook that waits 300ms after user stops typing before sending request.",
          "impact": "28 requests → 1 request. Much happier API server!",
          "code": {
            "hook": "export function useDebounce<T>(value: T, delay: number): T {\n  const [debouncedValue, setDebouncedValue] = useState<T>(value);\n\n  useEffect(() => {\n    const handler = setTimeout(() => {\n      setDebouncedValue(value);\n    }, delay);\n\n    return () => clearTimeout(handler);\n  }, [value, delay]);\n\n  return debouncedValue;\n}",
            "usage": "export const useTasks = () => {\n  const { taskFilters } = useFiltersStore();\n  \n  const debouncedFilters = useDebounce(taskFilters, 300);\n  \n  const queryInput = useMemo(\n    () => FilterService.prepareQueryFilters(debouncedFilters),\n    [debouncedFilters]\n  );\n  \n  const { data: tasks } = trpc.tasks.list.useQuery(queryInput, {\n    staleTime: 30000,\n  });\n};"
          }
        },
        {
          "id": "performance",
          "title": "Performance Optimization",
          "problem": "List of 50 task cards re-renders completely on every parent state change, even if tasks didn't change.",
          "solution": "Strategic use of useMemo, useCallback, and React.memo to prevent unnecessary re-renders.",
          "impact": "73% faster rendering! From 450ms to 120ms for 50 tasks.",
          "code": {
            "optimized": "export const KanbanBoard = () => {\n  const { tasks } = useTasks();\n  \n  const tasksByStatus = useMemo(() => {\n    return COLUMNS.reduce((acc, col) => {\n      acc[col.status] = tasks.filter(t => t.status === col.status);\n      return acc;\n    }, {} as Record<TaskStatus, Task[]>);\n  }, [tasks]);\n  \n  const handleDragEnd = useCallback((event: DragEndEvent) => {\n    const taskId = event.active.id as string;\n    const newStatus = event.over.id as TaskStatus;\n    setTaskStatus(taskId, newStatus);\n  }, [setTaskStatus]);\n  \n  return (\n    <DndContext onDragEnd={handleDragEnd}>\n      {COLUMNS.map(col => (\n        <Column \n          key={col.status}\n          tasks={tasksByStatus[col.status]}\n        />\n      ))}\n    </DndContext>\n  );\n};"
          }
        }
      ]
    },
    "gkpge-cms": {
      "title": "CMS Theme for PGE Group",
      "tagline": "Component system for corporate CMS",
      "description": "Designed and implemented a theme and reusable component library for PGE Capital Group's content management system. The project included refreshing visual identity while maintaining consistency across all group websites.",
      "overview": {
        "intro": "PGE Capital Group is Poland's largest energy company, with dozens of websites managed through an internal CMS. My task was to create a new, unified visual theme and set of components that could be used by all sites in the group.",
        "goals": [
          "Refresh visual identity according to new branding",
          "Create a library of reusable components",
          "Streamline the process of creating new sites",
          "Ensure visual consistency across all group websites"
        ]
      },
      "features": [
        {
          "title": "Component System",
          "description": "Over 40 reusable components from buttons to complex layouts"
        },
        {
          "title": "Responsiveness",
          "description": "Full responsiveness on all devices from mobile to desktop"
        },
        {
          "title": "Accessibility",
          "description": "WCAG 2.1 compliance to ensure accessibility for all users"
        },
        {
          "title": "Documentation",
          "description": "Detailed documentation of each component with usage examples"
        },
        {
          "title": "Scalability",
          "description": "Architecture enabling easy addition of new components"
        },
        {
          "title": "Performance",
          "description": "Optimized CSS and JS code for fast page loading"
        }
      ],
      "techStack": {
        "frontend": [
          "TWIG",
          "SCSS",
          "JavaScript ES6+",
          "BEM",
          "CSS Grid",
          "Flexbox"
        ],
        "backend": ["Symfony", "PHP", "MySQL", "Doctrine ORM"]
      },
      "comparison": {
        "title": "Visual Transformation",
        "beforeLabel": "Before",
        "afterLabel": "After"
      }
    },
    "gkpge-formbuilder": {
      "title": "FormBuilder for PGE CMS",
      "tagline": "Tool for building dynamic forms",
      "description": "Form-building tool with drag & drop interface, field dependency support, and ability to define custom actions after submission. FormBuilder was integrated with the capital group's internal CMS.",
      "overview": {
        "intro": "FormBuilder is a tool allowing content editors to create complex forms without developer involvement. The admin panel built with Angular enables visual form design, which is then exported as JSON and rendered by the Symfony backend. On the browser side, I created a dedicated TypeScript engine that, based on the dependency graph, recreates all dynamic behaviors defined in the builder.",
        "goals": [
          "Enable editors to create forms independently",
          "Implement field dependency system",
          "Create an intuitive drag & drop interface",
          "Ensure full client-side and server-side validation",
          "Build a dependency graph engine to recreate dynamic behaviors"
        ]
      },
      "features": [
        {
          "title": "Drag & Drop",
          "description": "Intuitive dragging of form components onto canvas"
        },
        {
          "title": "Field Dependencies",
          "description": "Define conditions for showing and hiding fields"
        },
        {
          "title": "Dependency Graph Engine",
          "description": "Dedicated TypeScript engine recreating dependencies based on field connection graph"
        },
        {
          "title": "Custom Actions",
          "description": "Configure behavior after form submission"
        },
        {
          "title": "Validation",
          "description": "Real-time validation on the client side"
        },
        {
          "title": "JSON Export",
          "description": "Form structure exported to JSON for backend"
        }
      ],
      "techStack": {
        "frontend": [
          "Angular 12+",
          "TypeScript",
          "RxJS",
          "Angular CDK",
          "SCSS"
        ],
        "backend": ["Symfony", "TWIG", "PHP", "MySQL"]
      },
      "process": {
        "title": "Project Implementation Process",
        "subtitle": "From initial business discussions to production deployment",
        "steps": [
          {
            "id": "discovery",
            "title": "Business Discussions",
            "period": "Week 1-2",
            "icon": "discovery",
            "description": "The project began with a series of meetings with the business team and content editors. I wanted to understand their daily problems and frustrations related to the current form creation process. It turned out that each new form required IT tickets and waiting up to several weeks for implementation.",
            "details": [
              "Conducted interviews with 8 content editors from different companies in the group",
              "Identified the main problem - too long time from idea to form publication",
              "Gathered requirements regarding field types and dependencies between them",
              "Established feature priorities with the product owner"
            ]
          },
          {
            "id": "planning",
            "title": "Architecture Planning",
            "period": "Week 3-4",
            "icon": "planning",
            "description": "After gathering requirements, it was time to design the system architecture. I had to make several key technical decisions - how to store form structure, how to handle dependencies between fields, and how to integrate the tool with the existing Symfony-based CMS.",
            "details": [
              "Decided on Angular due to its support for complex applications",
              "Designed JSON format for form structures",
              "Thought through a dependency system based on conditional rules",
              "Prepared technical documentation and data flow diagrams"
            ]
          },
          {
            "id": "development",
            "title": "Development Phase",
            "period": "Week 5-14",
            "icon": "development",
            "description": "The main implementation phase took about 10 weeks. I started with basic components like inputs and selects, then added drag & drop logic. The most difficult element was creating the dependency engine - I had to design a graph structure that allowed defining complex relationships between fields and their dynamic recreation on the browser side.",
            "details": [
              "Created a library of form components (input, select, checkbox, radio, textarea)",
              "Implemented drag & drop mechanism based on Angular CDK",
              "Designed and built dependency graph engine in TypeScript",
              "Engine analyzed JSON structure and built a graph of connections between fields",
              "Based on the graph, dynamically assigned listeners and recreated behaviors (show/hide, enable/disable, validations)",
              "Optimized graph traversal to avoid circular dependencies"
            ]
          },
          {
            "id": "testing",
            "title": "Testing",
            "period": "Week 15-17",
            "icon": "testing",
            "description": "Before deployment, I conducted intensive testing with real users. I invited a group of editors to beta testing, where they could create real forms and report problems. Thanks to their feedback, I improved many UX details.",
            "details": [
              "Conducted beta testing with 5 editors from different companies",
              "Fixed errors related to validation and state saving",
              "Optimized performance for large forms",
              "Added tooltips and hints based on user feedback"
            ]
          },
          {
            "id": "deployment",
            "title": "Deployment",
            "period": "Week 18-20",
            "icon": "deployment",
            "description": "Deployment was done in stages. First on the test environment, then on selected group sites, and finally on all websites. I also conducted training for editorial teams so they could fully utilize the tool's capabilities.",
            "details": [
              "Deployed the tool to production environment in readonly mode",
              "Conducted 3 training sessions for editorial teams",
              "Monitored metrics and collected feedback after deployment",
              "Developed user documentation and FAQ"
            ]
          }
        ]
      }
    },
    "gkpge-newsletter-pwa": {
      "title": "PGE Newsletter PWA",
      "tagline": "Offline-first internal newsletter application",
      "description": "Progressive Web App for PGE Capital Group's internal newsletter, designed with offline-first architecture, Service Workers, and a performance-focused React stack, consistently reaching Lighthouse scores of 95+ for performance and accessibility.",
      "overview": {
        "intro": "PGE Newsletter PWA is an internal web application used to distribute news and updates across the PGE Capital Group. The main goal was to ensure fast loading, offline access to content, and reliable behavior on devices with unstable network connectivity.",
        "goals": [
          "Provide offline-first access to newsletter content for employees",
          "Achieve and maintain high Lighthouse scores for performance and accessibility (95+)",
          "Optimize loading times on low-bandwidth connections",
          "Ensure a simple, maintainable React codebase for future extensions"
        ]
      },
      "features": [
        {
          "title": "Offline-first Architecture",
          "description": "Key newsletter views and assets cached via Service Workers so users can access content without network connectivity."
        },
        {
          "title": "Installable PWA",
          "description": "Support for add-to-home-screen behavior on desktop and mobile, with manifest configuration and app-like UX."
        },
        {
          "title": "Optimized Performance",
          "description": "Code splitting, image optimization and caching strategies designed to reach a sustained Lighthouse score of 95+."
        },
        {
          "title": "Accessible UI",
          "description": "Semantic HTML, keyboard navigation and ARIA attributes to align with internal accessibility requirements."
        }
      ],
      "techStack": {
        "frontend": [
          "React",
          "TypeScript",
          "React Router",
          "Styled Components or SCSS",
          "Lighthouse audits"
        ],
        "backend": [
          "REST API (internal)",
          "Node.js or existing PGE backend (integration layer)",
          "Caching layer for static content"
        ]
      },
      "highlights": [
        {
          "id": "offline-first-strategy",
          "title": "Offline-first Strategy with Service Workers",
          "problem": "Employees needed access to newsletter content on devices with unstable or limited connectivity, especially in field locations.",
          "solution": "Implemented a Service Worker with a cache-first strategy for static assets and critical views, with network-first for dynamic content where freshness mattered.",
          "impact": "Users can open the app and read previously loaded newsletters even without an active connection, reducing support tickets related to access issues."
        },
        {
          "id": "lighthouse-optimisation",
          "title": "Lighthouse 95+ Performance and Accessibility",
          "problem": "Initial prototypes showed inconsistent performance scores and missed accessibility checks.",
          "solution": "Iterative Lighthouse audits, image and font optimization, lazy loading for non-critical modules, and accessibility fixes (labels, roles, contrast).",
          "impact": "Stable Lighthouse scores of 95+ for performance and accessibility in CI pipeline, giving the team a measurable quality benchmark."
        },
        {
          "id": "background-refetch",
          "title": "Background Refetch with Fallback for iOS",
          "problem": "Users needed fresh newsletter content when their device came back online, even if the app wasn't actively open. Background Sync API works on Android but is not supported on iOS/Safari.",
          "solution": "Implemented Background Sync API for Android with Workbox-powered fallback for iOS. On iOS, used online event listeners combined with service worker activation to trigger refetch when user reopens the app or unlocks the screen.",
          "impact": "Android users get true background synchronization when connectivity returns. iOS users get automatic content refresh on app reopen, ensuring up-to-date content across all platforms despite API limitations.",
          "code": {
            "registration": "// Register background sync (Android)\nconst registration = await navigator.serviceWorker.ready;\nawait registration.sync.register('newsletter-sync');\n\n// Service Worker listener\nself.addEventListener('sync', event => {\n  if (event.tag === 'newsletter-sync') {\n    event.waitUntil(fetchLatestNewsletters());\n  }\n});",
            "iosFallback": "// iOS fallback - detect online and trigger sync\nwindow.addEventListener('online', async () => {\n  if ('serviceWorker' in navigator) {\n    const registration = await navigator.serviceWorker.ready;\n    // Trigger sync manually via message\n    registration.active.postMessage({\n      type: 'MANUAL_SYNC',\n      tag: 'newsletter-sync'\n    });\n  }\n});\n\n// Service Worker - handle manual sync\nself.addEventListener('message', event => {\n  if (event.data.type === 'MANUAL_SYNC') {\n    event.waitUntil(fetchLatestNewsletters());\n  }\n});"
          }
        }
      ]
    }
  }
}
